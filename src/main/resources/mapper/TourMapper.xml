<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="tkitem.backend.domain.tour.mapper.TourMapper">
    <insert id="insertTour" useGeneratedKeys="true" keyProperty="tourId" keyColumn="tour_id" parameterType="tkitem.backend.domain.tour.vo.Tour">
        INSERT INTO TOUR(title, provider, trip_code, duration_days, nights, itinerary_json, feature, summary, hotel_rating, img_url, created_at, updated_at)
        VALUES (#{title}, #{provider}, #{tripCode}, #{durationDays}, #{nights}, #{itineraryJson, jdbcType=CLOB}, #{feature}, #{summary}, #{hotelRating}, #{imgUrl}, SYSTIMESTAMP, SYSTIMESTAMP)
    </insert>

    <select id="findTourByTripCode" resultType="tkitem.backend.domain.tour.vo.Tour" parameterType="String">
        SELECT tour_id, title, provider, trip_code, duration_days, nights, itinerary_json, feature, summary, hotel_rating, img_url
        FROM TOUR
        WHERE trip_code = #{tripCode}
    </select>

    <insert id="insertTourPackage" parameterType="tkitem.backend.domain.tour.vo.TourPackage">
        INSERT INTO TOUR_PACKAGE(tour_id, price, departure_date, return_date, package_date_code, departure_airline, return_airline, booking_url, source_url, created_at, updated_at)
        VALUES (#{tourId}, #{price}, #{departureDate}, #{returnDate}, #{packageDateCode}, #{departureAirline}, #{returnAirline}, #{bookingUrl}, #{sourceUrl}, SYSTIMESTAMP, SYSTIMESTAMP)
    </insert>

    <insert id="insertTourDetailSchedule" parameterType="tkitem.backend.domain.tour.vo.TourDetailSchedule">
        INSERT INTO TOUR_DETAIL_SCHEDULE(tour_id, city_id, title, schedule_date, description, sort_order, default_type, created_at, updated_at)
        VALUES (#{tourId}, #{cityId}, #{title}, #{scheduleDate}, #{description}, #{sortOrder}, #{defaultType}, SYSTIMESTAMP, SYSTIMESTAMP)
    </insert>

    <insert id="insertTourCity" parameterType="tkitem.backend.domain.tour.vo.TourCity">
        INSERT INTO TOUR_CITY(city_id, tour_id, created_at, updated_at)
        VALUES (#{cityId}, #{tourId}, SYSTIMESTAMP, SYSTIMESTAMP)
    </insert>

    <select id="findPackageDateCodesByTourId" resultType="java.lang.String">
        SELECT PACKAGE_DATE_CODE FROM TOUR_PACKAGE WHERE TOUR_ID = #{tourId}
    </select>

    <!-- NEW: 선택된 투어들(tourIds)에 대해, 조건에 부합하는 모든 패키지 행을 조회 -->
    <select id="selectPackagesForTours"
            parameterType="map"
            resultType="tkitem.backend.domain.tour.dto.response.TourPackageDto">
        <!-- 기대 파라미터:
             - req: 추천 요청 DTO (기간/금액/그룹ID 포함)
             - memberId: Long (항상 존재)
             - tourIds: List<Long> (필수; 비어 있으면 결과 없음)
        -->
        WITH filtered_pkg AS (
            SELECT
                tp.tour_id,
                tp.tour_package_id,
                tp.price,
                tp.departure_date,
                tp.return_date,
                tp.booking_url,
                tp.departure_airline,
                tp.return_airline
            FROM TOUR_PACKAGE tp
            WHERE 1=1
            <!-- 같은 그룹에서 이미 추천된 '투어' 배제 -->
            <if test="req.groupId != null and req.groupId &gt; 0">
                AND NOT EXISTS (
                    SELECT 1
                    FROM TOUR_RECOMMENDATION tr
                    WHERE tr.tour_id     = tp.tour_id
                        AND tr.group_id  = #{req.groupId}
                        AND tr.member_id = #{memberId}
                )
            </if>

        <!-- 사용자가 이미 가진 '패키지' 배제(이력 중복 제거) -->
        AND NOT EXISTS (
            SELECT 1
            FROM TRIP t
            WHERE t.tour_package_id = tp.tour_package_id
                AND t.member_id     = #{memberId}
        )

        <!-- 기간/금액 필터 -->
        <if test="req != null and req.departureDate != null">
            AND tp.departure_date &gt;= TRUNC(#{req.departureDate, jdbcType=DATE})
        </if>
        <if test="req != null and req.returnDate != null">
            AND tp.return_date &lt; TRUNC(#{req.returnDate, jdbcType=DATE}) + 1
        </if>
        <if test="req != null and req.priceMin != null">
            AND tp.price &gt;= #{req.priceMin, jdbcType=NUMERIC}
        </if>
        <if test="req != null and req.priceMax != null">
            AND tp.price &lt;= #{req.priceMax, jdbcType=NUMERIC}
        </if>
        )
        SELECT
        fp.tour_id            AS "tourId",           <!-- Map 키: tourId (그룹핑용) -->
        fp.tour_package_id    AS "tourPackageId",    <!-- Map 키: tourPackageId -->
        fp.price              AS "price",            <!-- Map 키: price -->
        fp.departure_date     AS "departureDate",    <!-- Map 키: departureDate -->
        fp.return_date        AS "returnDate",       <!-- Map 키: returnDate -->
        fp.booking_url        AS "bookingUrl",       <!-- Map 키: bookingUrl -->
        fp.departure_airline  AS "departureAirline", <!-- Map 키: departureAirline -->
        fp.return_airline     AS "returnAirline"     <!-- Map 키: returnAirline -->
        FROM filtered_pkg fp
        WHERE
        <choose>
            <when test="tourIds != null and tourIds.size() &gt; 0">
                fp.tour_id IN
                <foreach collection="tourIds" item="id" open="(" close=")" separator=",">
                    #{id}
                </foreach>
            </when>
            <otherwise>
                1 = 0  <!-- tourIds 비었으면 결과 없음 -->
            </otherwise>
        </choose>
        ORDER BY fp.tour_id ASC,
        fp.departure_date ASC NULLS LAST,
        fp.price ASC NULLS LAST,
        fp.tour_package_id ASC
    </select>



    <select id="selectTourMetaByIds" parameterType="list" resultType="map">
        SELECT
            t.tour_id AS "tourId",
            t.title AS "title",
            t.feature AS "feature",
            t.img_url AS "imgUrl",
            t.provider AS "provider"
        FROM TOUR t
        WHERE t.tour_id IN
        <foreach collection="list" item="id" open="(" close=")" separator=",">
            #{id}
        </foreach>
    </select>

    <select id="selectTdsByTourIds" parameterType="map" resultType="map">
        SELECT
            tds.tour_id                  AS "tourId",
            tds.tour_detail_schedule_id  AS "tourDetailScheduleId",
            tds.city_id                  AS "cityId",
            c.country_name               AS "countryName",
            c.city_name                  AS "cityName",
            tds.title                    AS "title",
            tds.description              AS "description",
            tds.sort_order               AS "sortOrder",
            tds.default_type             AS "defaultType",
            tds.schedule_date            AS "scheduleDay"
        FROM TOUR_DETAIL_SCHEDULE tds
            LEFT JOIN CITY c ON c.city_id = tds.city_id
        WHERE tds.tour_id IN
        <foreach collection="list" item="id" open="(" close=")" separator=",">
            #{id}
        </foreach>
        ORDER BY
            tds.tour_id,
            NVL(tds.sort_order, 999999),
            tds.schedule_date
    </select>

    <select id="findTourPackageInfoByTourPackageId" resultType="tkitem.backend.domain.tour.dto.TourPackageInfo">
        SELECT
        tp.tour_package_id AS tourPackageId,
        tp.tour_id         AS tourId,
        tp.price           AS price,
        tp.departure_date  AS departureDate,
        tp.return_date     AS returnDate,
        tp.departure_airline AS departureAirline,
        tp.return_airline  AS returnAirline,
        tp.package_date_code AS packageDateCode,
        tp.booking_url     AS bookingUrl,
        tp.source_url      AS sourceUrl,
        t.title AS title,
        t.img_url AS imgUrl
        FROM TOUR_PACKAGE tp
        LEFT JOIN TOUR t ON tp.tour_id = t.tour_id
        WHERE tp.tour_package_id = #{tourPackageId}
    </select>

    <insert id="insertTourRecommendation" parameterType="map">
        INSERT INTO TOUR_RECOMMENDATION (
            tour_id,
            member_id,
            group_id,
            created_at,
            updated_at )
        VALUES (
            #{item.tourId},
            #{memberId},
            #{item.groupId},
            SYSTIMESTAMP,
            SYSTIMESTAMP )
    </insert>

    <resultMap id="TourPackageDetailMap"
               type="tkitem.backend.domain.tour.dto.response.TourPackageDetailDto">
        <!-- 투어 정보 -->
        <id     property="tourId"           column="tour_id"/>
        <result property="title"            column="title"/>
        <result property="feature"          column="feature"/>
        <result property="imgUrl"           column="img_url"/>
        <result property="provider"         column="provider"/>
        <result property="tourPackageId"    column="tour_package_id"/>

        <!-- 해당 투어의 전체 패키지 목록 -->
        <collection property="packageDtos"
                    ofType="tkitem.backend.domain.tour.dto.response.TourPackageDto"
                    select="selectPackagesByTourId"
                    column="tour_id"/>

        <!-- 스케줄 목록: tour_id를 column으로 넘겨 nested select 실행 -->
        <collection property="schedules"
                    ofType="tkitem.backend.domain.tour.dto.TourDetailScheduleDto"
                    select="selectSchedulesByTourId"
                    column="tour_id"/>
    </resultMap>

    <!-- 동일 tour_id의 전체 패키지 목록(필터 없이 모두 반환) -->
    <select id="selectPackagesByTourId"
            parameterType="long"
            resultType="tkitem.backend.domain.tour.dto.response.TourPackageDto">
        SELECT
            tp.tour_id          AS "tourId",
            tp.tour_package_id  AS "tourPackageId",
            tp.price            AS "price",
            tp.departure_date   AS "departureDate",
            tp.return_date      AS "returnDate",
            tp.booking_url      AS "bookingUrl",
            tp.departure_airline AS "departureAirline",
            tp.return_airline    AS "returnAirline"
        FROM TOUR_PACKAGE tp
        WHERE tp.tour_id = #{value}   <!-- nested select에서는 #{value} -->
        ORDER BY tp.departure_date ASC NULLS LAST,
            tp.price ASC NULLS LAST,
            tp.tour_package_id ASC
    </select>

    <!-- 패키지 + 투어 1건 조회 -->
    <select id="selectTourPackageDetail"
            parameterType="long"
            resultMap="TourPackageDetailMap">
        SELECT
        t.tour_id,
        t.title,
        t.feature,
        t.img_url,
        t.provider,
        tp.tour_package_id,
        tp.price,
        tp.departure_date,
        tp.return_date,
        tp.booking_url,
        tp.departure_airline,
        tp.return_airline
        FROM TOUR_PACKAGE tp
        JOIN TOUR t ON t.tour_id = tp.tour_id
        WHERE tp.tour_package_id = #{tourPackageId}
    </select>

    <!-- 동일 tour_id의 전체 세부일정 조회 -->
    <select id="selectSchedulesByTourId"
            parameterType="long"
            resultType="tkitem.backend.domain.tour.dto.TourDetailScheduleDto">
        SELECT
        s.tour_detail_schedule_id AS tourDetailScheduleId,
        s.city_id                 AS cityId,
        c.country_name            AS countryName,
        c.city_name               AS cityName,
        s.title                   AS title,
        s.description             AS description,
        s.sort_order              AS sortOrder,
        s.default_type            AS defaultType,
        s.schedule_date           AS scheduleDay
        FROM TOUR_DETAIL_SCHEDULE s
            LEFT JOIN CITY c ON c.city_id = s.city_id
        WHERE s.tour_id = #{value}  <!-- nested select 에서는 #{value} 사용 -->
        ORDER BY s.sort_order
    </select>

    <select id="selectTourDetailScheduleListByTourId" resultType="tkitem.backend.domain.tour.dto.TourDetailScheduleDto">
        SELECT
            tds.tour_detail_schedule_id AS tourDetailScheduleId,
            tds.city_id                 AS cityId,
            c.country_name              AS countryName,
            c.city_name                 AS cityName,
            tds.title                   AS title,
            tds.description             AS description,
            tds.sort_order              AS sortOrder,
            tds.default_type            AS defaultType,
            tds.schedule_date           AS scheduleDay
        FROM
            TOUR_DETAIL_SCHEDULE tds LEFT JOIN CITY c ON c.city_id = tds.city_id
        WHERE tds.tour_id = #{tourId}
        ORDER BY tds.sort_order
    </select>

    <!--  tour_receommendation 테이블의 다음으로 생성돼야할 groupId 찾기  -->
    <select id="selectNextGroupId" resultType="long">
        SELECT NVL(MAX(group_id), 0) + 1 AS nextGroupId
        FROM TOUR_RECOMMENDATION
    </select>

    <resultMap id="TourCommonRecommendDtoMap" type="tkitem.backend.domain.tour.dto.response.TourCommonRecommendDto">
        <!-- 단일 필드 -->
        <id     property="tourId"        column="tour_id"/>
        <result property="title"         column="title"/>
        <result property="feature"       column="feature"/>
        <result property="imgUrl"        column="img_url"/>
        <result property="provider"      column="provider"/>
        <result property="durationDays"  column="duration_days"/>
        <result property="nights"        column="nights"/>

        <result property="tourPackageId" column="tour_package_id"/>
        <result property="price"         column="price"/>
        <result property="departureDate" column="departure_date"/>
        <result property="returnDate"    column="return_date"/>
        <result property="bookingUrl"    column="booking_url"/>
        <result property="departureAirline" column="departure_airline"/>
        <result property="returnAirline"    column="return_airline"/>

        <!-- [ADD] locations: 별도 쿼리로 N+1 매핑 -->
        <collection property="locations"
                    ofType="tkitem.backend.domain.tour.dto.LocationInfo"
                    column="tour_id"
                    select="selectLocationsByTourId"/>
    </resultMap>

    <select id="selectLocationsByTourId" parameterType="long" resultType="tkitem.backend.domain.tour.dto.LocationInfo">
        SELECT DISTINCT
            c.country_group_name AS countryGroup,
            c.country_name       AS country,
            c.city_name          AS city
        FROM TOUR_CITY tc
            JOIN CITY c ON c.city_id = tc.city_id
        WHERE tc.tour_id = #{_parameter}
    </select>

    <select id="selectTourMetaByMemberId" parameterType="long" resultMap="TourCommonRecommendDtoMap">
        WITH ex_group AS (
        SELECT DISTINCT tr_map.group_id
        FROM TRIP trip
        JOIN TOUR_PACKAGE tp2       ON tp2.tour_package_id = trip.tour_package_id
        JOIN TOUR_RECOMMENDATION tr_map ON tr_map.tour_id = tp2.tour_id
        WHERE trip.member_id   = #{memberId}
        AND tr_map.member_id = #{memberId}
        AND tr_map.group_id IS NOT NULL
        ),
        rep_pkg AS (
        SELECT tp.*,
        ROW_NUMBER() OVER (
        PARTITION BY tp.tour_id
        ORDER BY tp.price ASC NULLS LAST,
        tp.departure_date ASC NULLS LAST,
        tp.tour_package_id ASC
        ) rn
        FROM TOUR_PACKAGE tp
        )
        SELECT
        t.tour_id,
        t.title,
        t.feature,
        t.img_url,
        t.provider,
        t.duration_days,
        t.nights,
        rp.tour_package_id,
        rp.price,
        rp.departure_date,
        rp.return_date,
        rp.booking_url,
        rp.departure_airline,
        rp.return_airline
        FROM TOUR_RECOMMENDATION tr
        JOIN TOUR t      ON t.tour_id  = tr.tour_id
        LEFT JOIN rep_pkg rp ON rp.tour_id = tr.tour_id AND rp.rn = 1
        WHERE tr.member_id = #{memberId}
        AND NOT EXISTS (SELECT 1 FROM ex_group g WHERE g.group_id = tr.group_id)
        ORDER BY tr.created_at DESC
        FETCH FIRST 15 ROWS ONLY
    </select>

    <select id="selectTourMetaByTripSaved" resultMap="TourCommonRecommendDtoMap">
        WITH trip_cnt AS (
            SELECT tp.tour_id, COUNT(*) AS cnt
            FROM TRIP t
                JOIN TOUR_PACKAGE tp ON tp.tour_package_id = t.tour_package_id
            GROUP BY tp.tour_id
        ),
        filtered_pkg AS (
            SELECT
                tour_id,
                tour_package_id,
                price,
                departure_date,
                return_date,
                booking_url,
                departure_airline,
                return_airline
            FROM TOUR_PACKAGE
            WHERE departure_date &gt;= TRUNC(SYSDATE)
                AND departure_date &lt; TRUNC(SYSDATE) + 8
        ),
        rep_pkg AS (
            SELECT fp.*,
                ROW_NUMBER() OVER (
                    PARTITION BY fp.tour_id
                    ORDER BY fp.price ASC NULLS LAST,
                        fp.departure_date ASC NULLS LAST,
                        fp.tour_package_id ASC
                ) rn
            FROM filtered_pkg fp
        )
        SELECT
            t.tour_id,
            t.title,
            t.feature,
            t.img_url,
            t.provider,
            t.duration_days,
            t.nights,
            rp.tour_package_id,
            rp.price,
            rp.departure_date,
            rp.return_date,
            rp.booking_url,
            rp.departure_airline,
            rp.return_airline
        FROM rep_pkg rp
            JOIN trip_cnt tc ON tc.tour_id = rp.tour_id
            JOIN TOUR t      ON t.tour_id  = rp.tour_id
        WHERE rp.rn = 1
            AND NOT EXISTS (
                SELECT 1
                FROM TRIP t2
                    JOIN TOUR_PACKAGE tp2 ON tp2.tour_package_id = t2.tour_package_id
                WHERE t2.member_id = #{memberId}
                    AND tp2.tour_id  = t.tour_id
            )
        <if test="countryGroup != null and countryGroup != ''">
            AND EXISTS (
                SELECT 1
                FROM TOUR_CITY tci
                    JOIN CITY c ON c.city_id = tci.city_id
                WHERE tci.tour_id = t.tour_id
                    AND c.country_group_name = #{countryGroup}
            )
        </if>
        ORDER BY tc.cnt DESC, rp.price ASC, rp.departure_date ASC
        FETCH FIRST #{topN} ROWS ONLY
    </select>

    <select id="selectAllowTourIdsByCountry" parameterType="string" resultType="long">
        SELECT DISTINCT tc.tour_id
        FROM CITY c
        JOIN TOUR_CITY tc ON tc.city_id = c.city_id
        WHERE c.country_name = #{country}
    </select>

    <select id="selectAllowTourIdsByCountryGroup" parameterType="string" resultType="long">
        SELECT DISTINCT tc.tour_id
        FROM CITY c
        JOIN TOUR_CITY tc ON tc.city_id = c.city_id
        WHERE c.country_group_name = #{countryGroup}
    </select>

    <select id="selectTourMetaByTourIds" parameterType="map" resultMap="TourCommonRecommendDtoMap">
        WITH pkg_one AS (
            SELECT
                tp.*,
                ROW_NUMBER() OVER (
                    PARTITION BY tp.tour_id
                    ORDER BY
                        CASE WHEN tp.price IS NULL THEN 1 ELSE 0 END,   -- NULL 가격은 뒤로
                        tp.price,                                       -- 최저가 우선
                        tp.departure_date,                              -- 같은 가격이면 빠른 출발
                        tp.tour_package_id                              -- 마지막 타이브레이커
                ) ranking
            FROM TOUR_PACKAGE tp
        )
        SELECT
            t.tour_id,
            t.title,
            t.feature,
            t.img_url,
            t.provider,
            t.duration_days,
            t.nights,
            p.tour_package_id,
            p.price,
            p.departure_date,
            p.return_date,
            p.booking_url,
            p.departure_airline,
            p.return_airline
        FROM TOUR t
            LEFT JOIN pkg_one p ON p.tour_id = t.tour_id AND p.ranking = 1
        WHERE t.tour_id IN
            <foreach item="id" collection="ids" open="(" separator="," close=")">
                #{id}
            </foreach>
            ORDER BY CASE
            <foreach item="id" collection="ids" index="idx" separator=" ">
                WHEN t.tour_id = #{id} THEN #{idx}
            </foreach>
            ELSE 999999
        END
    </select>

    <select id="selectTourIdsByFilters" resultType="long" fetchSize="20">
        SELECT /*+ PARALLEL(2) */ t.tour_id
        FROM TOUR t
        WHERE
        <!-- 날짜/가격 조건을 만족하는 패키지가 '존재'해야 함 -->
        EXISTS (
        SELECT 1
        FROM TOUR_PACKAGE tp
        WHERE tp.tour_id = t.tour_id

        <!-- 날짜 overlap -->
        <if test="depStart != null or retEnd != null">
            AND
            (
            1=1
            <if test="depStart != null and retEnd != null">
                AND tp.departure_date &gt;= #{depStart}
                AND tp.return_date &lt; #{retEnd} + 1
            </if>
            <if test="depStart != null and retEnd == null">
                <!-- retEnd 미지정: 시작일 이후에 끝나는 패키지면 통과 -->
                AND tp.return_date   &gt;= #{depStart}
            </if>
            <if test="depStart == null and retEnd != null">
                <!-- depStart 미지정: 종료일 이전에 시작하는 패키지면 통과 -->
                AND tp.departure_date &lt;= #{retEnd}
            </if>
            )
        </if>

        <!-- 가격 -->
        <if test="priceMin != null">
            AND tp.price &gt;= #{priceMin}
        </if>
        <if test="priceMax != null">
            AND tp.price &lt;= #{priceMax}
        </if>
        )

        <!-- 지역 OR 매칭 -->
        <if test="locations != null and locations.size() &gt; 0">
            AND EXISTS (
            SELECT 1
            FROM TOUR_CITY tc
            JOIN CITY c ON c.city_id = tc.city_id
            WHERE tc.tour_id = t.tour_id
            AND (
            <!-- locations 항목들을 OR 로 연결 -->
            <foreach collection="locations" item="loc" separator=" OR ">
                (
                <!-- 1) city가 주어졌다면 city로 매칭 -->
                <if test="loc.city != null and loc.city.trim().length() &gt; 0">
                    c.city_name = #{loc.city}
                    <!-- country/countryGroup가 같이 왔다면 그까지 '추가로' 제한 -->
                    <if test="loc.country != null and loc.country.trim().length() &gt; 0">
                        AND c.country_name = #{loc.country}
                    </if>
                    <if test="loc.countryGroup != null and loc.countryGroup.trim().length() &gt; 0">
                        AND c.country_group_name = #{loc.countryGroup}
                    </if>
                </if>

                <!-- 2) city는 없고 country가 주어졌다면 country로 매칭 -->
                <if test="(loc.city == null or loc.city.trim().length() == 0)
                                        and (loc.country != null and loc.country.trim().length() &gt; 0)">
                    c.country_name = #{loc.country}
                    <if test="loc.countryGroup != null and loc.countryGroup.trim().length() &gt; 0">
                        AND c.country_group_name = #{loc.countryGroup}
                    </if>
                </if>

                <!-- 3) city/country 모두 없고 countryGroup만 주어졌다면 group으로 매칭 -->
                <if test="(loc.city == null or loc.city.trim().length() == 0)
                                        and (loc.country == null or loc.country.trim().length() == 0)
                                        and (loc.countryGroup != null and loc.countryGroup.trim().length() &gt; 0)">
                    c.country_group_name = #{loc.countryGroup}
                </if>
                )
            </foreach>
            )
        )
        </if>
        <!--    회원에게 추천된 투어면 제외    -->
        <if test="memberId != null">
            AND NOT EXISTS (
                SELECT 1
                FROM TOUR_RECOMMENDATION tr
                WHERE tr.tour_id = t.tour_id
                    AND tr.member_id = #{memberId}
                    <if test="groupId != null or groupId != 0">
                        AND tr.group_id = #{groupId}
                    </if>
            )
        </if>
    </select>

    <select id="scoreByIdsInline"
            parameterType="map"
            resultType="tkitem.backend.domain.tour.dto.TourCandidateRowDto"
            fetchSize="1000">
        WITH
        /* allowIdsJson: "[101,102,...]" 형태의 JSON 배열 문자열 */
        ids AS (
            SELECT jt.tour_id
            FROM JSON_TABLE(
                #{allowIdsJson, jdbcType=CLOB},
                '$[*]'
                COLUMNS ( tour_id NUMBER PATH '$' )
            ) jt
        ),
        /* REST 타입 식별 */
        st_rest AS (
            SELECT schedule_type_id AS rest_id
            FROM SCHEDULE_TYPE
            WHERE UPPER(name) = 'REST'
        ),
        /* 태그 가중치(없으면 나중에 1.0 처리) */
        sel_tag AS (
            SELECT schedule_type_id, AVG(weight) AS avg_weight
            FROM SCHEDULE_TYPE_TAG
            <if test="tagIdList != null and tagIdList.size() &gt; 0">
                WHERE tag_id IN (
                <foreach collection="tagIdList" item="tid" separator=",">#{tid}</foreach>
                )
            </if>
            GROUP BY schedule_type_id
        ),
        /* allowIds 대상의 일정×유형 원천 */
        tst_base AS (
            SELECT
                tds.tour_id,
                tds.tour_detail_schedule_id AS tds_id,
                TRUNC(tds.schedule_date)    AS schedule_date,
                tds.default_type,
                tst.schedule_type_id,
                tst.score
            FROM ids
                JOIN TOUR_DETAIL_SCHEDULE tds ON tds.tour_id = ids.tour_id
                JOIN TOUR_SCHEDULE_TYPE   tst ON tst.tour_detail_schedule_id = tds.tour_detail_schedule_id
        ),
        /* ACCOMMODATION 에서의 REST: 같은 날 평균 1건으로 축약 */
        rest_accom_day AS (
            SELECT
                b.tour_id,
                b.schedule_date,
                r.rest_id AS schedule_type_id,
                AVG(b.score) AS avg_score
            FROM tst_base b
            JOIN st_rest r ON r.rest_id = b.schedule_type_id
            WHERE UPPER(NVL(b.default_type,'X')) = 'ACCOMMODATION'
            GROUP BY b.tour_id, b.schedule_date, r.rest_id
        ),
        /* 비-숙소 REST + 기타(행 유지) */
        non_rest_rows AS (
            SELECT
                b.tour_id, b.schedule_date, b.tds_id, b.schedule_type_id,
                b.score AS base_score
            FROM tst_base b
            LEFT JOIN st_rest r ON r.rest_id = b.schedule_type_id
            WHERE r.rest_id IS NULL OR UPPER(NVL(b.default_type,'X')) &lt;&gt; 'ACCOMMODATION'
        ),
        /* 숙소 REST 보정행으로 변환 */
        rest_rows AS (
            SELECT
                r.tour_id, r.schedule_date,
                CAST(NULL AS NUMBER) AS tds_id,
                r.schedule_type_id, r.avg_score AS base_score
            FROM rest_accom_day r
        ),
        /* 태그 가중치 적용: 태그 있으면 sum_weight, 없으면 1.0(미매칭은 0) */
        scored AS (
            SELECT
                x.tour_id, x.schedule_date, x.tds_id, x.schedule_type_id,
                (
                    <if test="tagIdList != null and tagIdList.size() &gt; 0">
                        NVL(s.avg_weight, 0)
                    </if>
                    <if test="!(tagIdList != null and tagIdList.size() &gt; 0)">
                        1
                    </if>
                ) * x.base_score AS s
            FROM (
                SELECT * FROM non_rest_rows
                UNION ALL
                SELECT * FROM rest_rows
            ) x
            LEFT JOIN sel_tag s ON s.schedule_type_id = x.schedule_type_id
        ),
        /* (tour, day, unit) 합산 (숙소 REST는 unit_id=-1) */
        unit_score AS (
            SELECT
                tour_id,
                schedule_date,
                NVL(tds_id,-1) AS unit_id,
                SUM(s) AS unit_s
            FROM scored
            GROUP BY tour_id, schedule_date, NVL(tds_id,-1)
        ),
        /* 일자별 Top-N 유닛 */
        ranked_day AS (
            SELECT
                u.*,
                ROW_NUMBER() OVER (PARTITION BY u.tour_id, u.schedule_date ORDER BY u.unit_s DESC) AS rn_day
            FROM unit_score u
        ),
        /* 일자 점수 */
        day_score AS (
            SELECT
                r.tour_id,
                r.schedule_date,
                SUM(CASE WHEN r.rn_day &lt;= #{nPerDay} THEN r.unit_s ELSE 0 END) AS day_s
            FROM ranked_day r
            GROUP BY r.tour_id, r.schedule_date
        ),
        /* 최종 점수: 일자 평균(길이 보정) */
        tour_score AS (
            SELECT
                d.tour_id,
                AVG(d.day_s) AS finalScore
            FROM day_score d
            GROUP BY d.tour_id
        ),
        /* 최저가/대표패키지 요약 (allowIds 한정) */
        pkg_agg AS (
            SELECT
                tp.tour_id,
                MIN(tp.price)          AS min_price,
                MAX(tp.departure_date) AS latest_departure
            FROM TOUR_PACKAGE tp
                JOIN ids ON ids.tour_id = tp.tour_id
            GROUP BY tp.tour_id
        ),
        rep_pkg AS (
            SELECT
                tp.tour_id,
                MIN(tp.tour_package_id) KEEP (DENSE_RANK FIRST ORDER BY tp.price NULLS LAST, tp.departure_date NULLS LAST, tp.tour_package_id) AS repTourPackageId,
                MIN(tp.price) KEEP (DENSE_RANK FIRST ORDER BY tp.price NULLS LAST, tp.departure_date NULLS LAST, tp.tour_package_id) AS repPrice,
                MIN(tp.departure_date) KEEP (DENSE_RANK FIRST ORDER BY tp.price NULLS LAST, tp.departure_date NULLS LAST, tp.tour_package_id) AS repDepartureDate,
                MIN(tp.return_date) KEEP (DENSE_RANK FIRST ORDER BY tp.price NULLS LAST, tp.departure_date NULLS LAST, tp.tour_package_id) AS repReturnDate,
                MIN(tp.booking_url) KEEP (DENSE_RANK FIRST ORDER BY tp.price NULLS LAST, tp.departure_date NULLS LAST, tp.tour_package_id) AS repBookingUrl,
                MIN(tp.departure_airline) KEEP (DENSE_RANK FIRST ORDER BY tp.price NULLS LAST, tp.departure_date NULLS LAST, tp.tour_package_id) AS repDepartureAirline,
                MIN(tp.return_airline) KEEP (DENSE_RANK FIRST ORDER BY tp.price NULLS LAST, tp.departure_date NULLS LAST, tp.tour_package_id) AS repReturnAirline
            FROM TOUR_PACKAGE tp
                JOIN ids ON ids.tour_id = tp.tour_id
            GROUP BY tp.tour_id
        )
        SELECT
            ts.tour_id              AS "tourId",
            ts.finalScore           AS "sDbRaw",
            pa.min_price            AS "minPrice",
            pa.latest_departure     AS "latestDeparture",
            rp.repTourPackageId     AS "repTourPackageId",
            rp.repPrice             AS "repPrice",
            rp.repDepartureDate     AS "repDepartureDate",
            rp.repReturnDate        AS "repReturnDate",
            rp.repBookingUrl        AS "repBookingUrl",
            rp.repDepartureAirline  AS "repDepartureAirline",
            rp.repReturnAirline     AS "repReturnAirline"
        FROM tour_score ts
            LEFT JOIN pkg_agg pa ON pa.tour_id = ts.tour_id
            LEFT JOIN rep_pkg  rp ON rp.tour_id = ts.tour_id
        WHERE NVL(ts.finalScore, 0) &gt; 0
        ORDER BY ts.finalScore DESC, pa.min_price ASC, pa.latest_departure ASC
    </select>
</mapper>